from math import gcd
def main():
    """this is main function."""
    print("hello world!")
    Test.start()

class Test:
    @staticmethod
    def test_primRoots():
        obj = primRoots(37)
        print(obj) # turns out obj is a list.


    @staticmethod
    def create_AB(g, p, a, b):
        A = g**a % p
        B = g**b % p
        return A, B
    @classmethod
    def start(cls):
        cls.test_get_pubk()
        cls.test_crack()

    @staticmethod
    def test_get_pubk():
        print(DHK.get_pubk(5, 13, 11)) # 8
        print(DHK.get_pubk(5, 13, 7)) # 8
        print(DHK.get_pubk(5, 13, 7)) # 8

    @staticmethod
    def test_crack():
        print("----")
        dhk = DHK(5, 13, 8, 8) # answer is a = 11 / b = 7 / s = 5
        dhk.crack(15)

        print("----")
        dhk = DHK(2, 11, 6, 5) # answer is a = 9 / b = 5 / s = 9
        dhk.crack(15)

        print("----")
        dhk = DHK(5, 23, 4, 10) # answer is a=4 / b=3 / s=18
        dhk.crack(15)

        print("----")
        dhk = DHK(5, 97, 50, 44) # 36 / 58 / 75
        dhk.crack(100)

        print("----")
        dhk = DHK(3, 353, 40, 248) # 97 / 233 / 160
        dhk.crack(300)

        maxn = 20
        trial = 0
        uniq = 0
        #for i in (1, 2, 3, 5, 8, 11, 14, 15, 21, 27, 24, 35, 35, 34, 45, 51, 56, 59): # from wikipedia primitive root modulo
        for j in (25, 29, 31, 37, 41, 43, 47):
            for i in primRoots(j):
                for k in range(2, maxn):
                    for l in range(2, maxn):
                        A,B = Test.create_AB(i, j, k, l)
                        print("----")
                        print("g :", i, "p :", j, "a :", k, "b :", l)
                        dhk = DHK(i, j, A, B) # 97 / 233 / 160
                        lenS = dhk.crack(maxn)
                        trial += 1
                        if lenS == 1:
                            uniq += 1

        print("trial:", trial)
        print("uniq: ", uniq)





class DHK: # diffie hellman key exchange
    def __init__(self, g, p, A, B):
        self.g = g;
        self.p = p;
        self.A = A;
        self.B = B;

    @staticmethod
    def get_pubk(g, p, prvk):
        return (g ** prvk) % p

    @staticmethod
    def pow_mod(pubk, prvk, p):
        return (pubk ** prvk) % p

    def crack(self, max_guess):
        cand_a = []
        cand_b = []

        # tmpA must be equal to self.A
        for i in range(2, max_guess):
            tmp = DHK.get_pubk(self.g, self.p, i)
            if (tmp == self.A):
                cand_a.append(i)
            if (tmp == self.B):
                cand_b.append(i)

        print("these a values produce A:", end="")
        print_arr(cand_a)
        print("these b values produce B:", end="")
        print_arr(cand_b)
        cand_s_from_a = []
        for i in cand_a:
            cand_s_from_a.append(DHK.pow_mod(self.B, i, self.p))

        print("S :", end="")
        print_arr(cand_s_from_a)

        # in case I know b
        # cand_s_from_b is a list of S candidates generated by A ** b mod p
        cand_s_from_b = []
        for i in cand_b:
            cand_s_from_b.append(DHK.pow_mod(self.A, i, self.p))
        print("S :", end="")
        print_arr(cand_s_from_b)

        return len(cand_s_from_a)



def print_arr(arr):
    for i in arr:
        print(i, end = "-")
    print("")
# https://stackoverflow.com/questions/40190849/efficient-finding-primitive-roots-modulo-n-using-python
def primRoots(modulo):
    required_set = {num for num in range(1, modulo) if gcd(num, modulo)}
    return [g for g in range(1, modulo) if required_set == {pow(g, powers, modulo)
            for powers in range(1, modulo)}]

# known inputs are A, B, g, p. You need to guess a and b to derive s.


if __name__ == "__main__" :
    main()

